#!/bin/bash

[ ${debug} ] && set -o xtrace

UC_ENABLED=
LM_ENABLED=
SFA_ENABLED=
FORCE=0
APPEND=0
INTERACTIVE=1
DEFAULT_USER=root
INSTALL_UC=0
INSTALL_LM=0
INSTALL_SFA=0
MQTT_HOST=
MQTT_PORT=
MQTT_USER=
MQTT_PASSWORD=
MQTT_SPACE=
MQTT_CAFILE=
MQTT_CERT=
MQTT_KEY=
MQTT_ANNOUNCE_ENABLED=0
MQTT_DISCOVERY_ENABLED=0
LINK=0
ALLOW_ROOT=0
BENCHMARK=0
DEFAULT_CA_FILE=/etc/ssl/certs/ca-certificates.crt

REMOTES='0.0.0.0/0'

VALUE=

REQUIRED="realpath python3 pip3 sha256sum curl"

MAX_START_WAIT=180

function usage {
    echo "Usage: easy-setup [--force] [--clear] [--auto] [--local-only] [-u USER]"
    echo "          [--link] [--mqtt user:password@host:port/space] [-p {uc,lm,sfa,all}]"
    echo
    echo " Options:"
    echo
    echo " --force                  force install even if configs are already present"
    echo
    echo " --clear                  clear runtime (recommended with --force,"
    echo "                          WARNING!!! destroys all data)"
    echo
    echo " --auto                   perform automatic (unattended) setup"
    echo
    echo " Options for the automatic setup:"
    echo
    echo " --local-only             accept API keys (except operator) only from local host"
    echo " -u USER                  set up all controllers to run under specified user"
    echo
    echo " --link                   link all controllers statically (requires --mqtt)"
    echo "                          WARNING: it's not possible to change controller id"
    echo "                          after linking. IDs of all controllers are automatically"
    echo "                          set to the current host name. If you want to use different"
    echo "                          IDs, prepare etc/uc.ini and etc/lm.ini files first and"
    echo "                          set 'name' key there"
    echo
    echo " --mqtt user:password@host:port/space"
    echo "                          specify MQTT server access"
    echo " --mqtt-cafile FILE       MQTT CA file to enable MQTT via SSL"
    echo " --mqtt-cert FILE         MQTT authorization cert"
    echo " --mqtt-key FILE          MQTT authorization key"
    echo " --mqtt-announce          Enable MQTT announces and API calls via MQTT"
    echo " --mqtt-discovery         Enable autodiscovery of other nodes via MQTT"
    echo
    echo " -p {uc|lm|sfa|all}       specify which controller to set up or all, may be used"
    echo "                          several times"
}

function option_error {
    usage
    exit 2
}


function start_controller() {
    ./sbin/$1-control start
    I=0
    sleep 0.5
    ./sbin/eva-tinyapi -C $1 -F test > /dev/null 2>&1
    R=$?
    if [ $R -eq 9 ]; then
        echo " configs missing!"
        return 1
    fi
    echo -n "$1: ." | tr "a-z" "A-Z"
    while [ $R -ne 0 ]; do
        if [ $I -gt ${MAX_START_WAIT} ]; then
            echo " failed to start!"
            return 2
        fi
        I=`expr $I + 1`
        sleep 0.5
        echo -n "."
        ./sbin/eva-tinyapi -C $1 -F test > /dev/null 2>&1
        R=$?
    done
    echo " started"
    return 0
}

function save_controller_state {
    (./sbin/eva-tinyapi -S -C $1 -F save | grep OK) > /dev/null 2>&1 || return 1
}

function create_operator_key {
    local P=$1
    ./sbin/eva-tinyapi -S -C $P -F list_key_props i=operator | grep ERROR > /dev/null 2>&1 || return 0
    (./sbin/eva-tinyapi -S -C $P -F create_key \
        i=operator | grep key) > /dev/null 2>&1 || return 1
    (./sbin/eva-tinyapi -S -C $P -F set_key_prop \
        i=operator p=key v=$OPKEY | grep OK) > /dev/null 2>&1 || return 1
    (./sbin/eva-tinyapi -S -C $P -F set_key_prop \
        i=operator p=groups v='#' | grep OK) > /dev/null 2>&1 || return 1
    (./sbin/eva-tinyapi -S -C $P -F set_key_prop \
        i=operator p=pvt v='#' | grep OK) > /dev/null 2>&1 || return 1
    (./sbin/eva-tinyapi -S -C $P -F set_key_prop \
        i=operator p=allow v=lock,dm_rule_props,dm_rules_list | grep OK) > /dev/null 2>&1 || return 1
    (./sbin/eva-tinyapi -S -C $P -F set_key_prop \
        i=operator p=sysfunc v=1 | grep OK) > /dev/null 2>&1 || return 1
    return 0
}

function create_default_key {
    local P=$1
    local ALLOW=$2
    ./sbin/eva-tinyapi -S -C $P -F list_key_props i=default | grep ERROR > /dev/null 2>&1 || return 0
    (./sbin/eva-tinyapi -S -C $P -F create_key \
        i=default | grep key) > /dev/null 2>&1 || return 1
    (./sbin/eva-tinyapi -S -C $P -F set_key_prop \
        i=default p=key v=$DEFAULTKEY | grep OK) > /dev/null 2>&1 || return 1
    (./sbin/eva-tinyapi -S -C $P -F set_key_prop \
        i=default p=groups v='#' | grep OK) > /dev/null 2>&1 || return 1
    (./sbin/eva-tinyapi -S -C $P -F set_key_prop \
        i=default p=allow v=$ALLOW | grep OK) > /dev/null 2>&1 || return 1
    (./sbin/eva-tinyapi -S -C $P -F set_key_prop \
        i=default p=hosts_allow v=$REMOTES | grep OK) > /dev/null 2>&1 || return 1
    return 0
}

function create_notifier {
    local T=$1
    local BATCH=
    if [ "x$MQTT_HOST" != "x" ]; then
        echo "Creating notifier for ${T}"
        local sp=
        [ "x${MQTT_SPACE}" != "x" ] && local sp="-s ${MQTT_SPACE}"
        local auth=
        [ "x$MQTT_USER" != "x" ] && local auth="${MQTT_USER}"
        [ "x$MQTT_PASSWORD" != "x" ] && local auth="$auth:${MQTT_PASSWORD}"
        [ "x$auth" != "x" ] && auth="${auth}@"
        local port=
        [ "x${MQTT_PORT}" != "x" ] && port=":${MQTT_PORT}"
        BATCH="create eva_1 mqtt:${auth}${MQTT_HOST}${port} ${sp} -y"
        if [ "x$MQTT_CAFILE" != "x" ]; then
            BATCH="$BATCH;set eva_1 ca_certs $MQTT_CAFILE"
        fi
        if [ "x$MQTT_CERT" != "x" ]; then
            BATCH="$BATCH;set eva_1 certfile $MQTT_CERT"
        fi
        if [ "x$MQTT_KEY" != "x" ]; then
            BATCH="$BATCH;set eva_1 key $MQTT_KEY"
        fi
        BATCH="$BATCH;subscribe state eva_1 -p '#' -g '#'"
        BATCH="$BATCH;subscribe log eva_1"
        if [ "x$MQTT_ANNOUNCE_ENABLED" == "x1" ]; then
            BATCH="$BATCH;set eva_1 api_enabled 1"
            BATCH="$BATCH;set eva_1 announce_interval 30"
        fi
        [ "x$MQTT_DISCOVERY_ENABLED" == "x1" ] && [ $T != 'uc' ] && BATCH="$BATCH;set eva_1 discovery_enabled 1"
        BATCH="$BATCH;test eva_1"
        if [ "x$T" = "xsfa" ]; then
            [ "x$BATCH" != "x" ] && BATCH="$BATCH;"
            BATCH="${BATCH}set eva_1 collect_logs 1"
            BATCH="${BATCH};create db_1 db:db/sfa_history.db -y;subscribe state db_1 -p '#' -g '#'"
        fi
    fi
    [ "x${BATCH}" = "x" ] && return 0
    echo $BATCH | ./bin/$T-notifier -R --exec-batch=stdin
    return $?
}

function check_required_exec {
    local p=$1
    echo -n "Checking $p => "
    RESULT=`which $p 2>&1`
    if [ $? != 0 ]; then
        echo "Missing! Please install"
        return 1
    fi
    echo ${RESULT}
    return 0
}

function askYN {
    if [ $INTERACTIVE -ne 1 ]; then
        VALUE=2
        return
    fi
    local v=
    while [ "x$v" == "x" ]; do
        echo -n "$1 (Y/N, default Y)? "
        read a
        if [ "x$a" = "x" ]; then
            v=1
        else
            case $a in
                y|Y)
                    v=1
                ;;
                n|N)
                    v=0
                ;;
            esac
        fi
    done
    VALUE=$v
}

function askMQTT {
    while [ 1 ]; do
        if [ $INTERACTIVE -eq 1 ]; then
            echo -n "MQTT host, required for linking (use empty value to skip MQTT connection for now): "
            read MQTT_HOST
            if [ "x${MQTT_HOST}"  = "x" ]; then
                return
            fi
            echo -n "MQTT port [1883]: "
            read MQTT_PORT
            [ "x${MQTT_PORT}" = "x" ] && MQTT_PORT=1883
            MQTT_USER=
            echo -n "MQTT user (empty for none): "
            read MQTT_USER
            MQTT_PASSWORD=
            if [ "x$MQTT_USER" != "x" ]; then
                echo -n "MQTT password (empty for none): "
                read -s MQTT_PASSWORD
                echo
            fi
            echo -n "MQTT space (empty for the root hive): "
            read MQTT_SPACE
            askYN "Enable MQTT SSL"
            MQTT_CAFILE=
            if [ $VALUE == "1" ]; then
                while [ 1 ]; do
                    echo -n "MQTT CA file ($DEFAULT_CA_FILE): "
                    read MQTT_CAFILE
                    [ "x$MQTT_CAFILE" == "x" ] && MQTT_CAFILE=$DEFAULT_CA_FILE
                    if [ ! -f "$MQTT_CAFILE" ]; then
                        echo "No such file: $MQTT_CAFILE"
                    else
                        break
                    fi
                done
                while [ 1 ]; do
                    echo -n "MQTT cert file (empty for none): "
                    read MQTT_CERT
                    [ "x$MQTT_CERT" == "x" ] || [ -f "$MQTT_CERT" ] ; break
                done
                if [ "x$MQTT_CERT" != "x" ]; then
                    while [ 1 ]; do
                        echo -n "MQTT key file (empty for none): "
                        read MQTT_KEY
                        [ "x$MQTT_KEY" == "x" ] || [ -f "$MQTT_KEY" ] ; break
                    done
                fi
            fi
        else
            if [ "x${MQTT_HOST}"  = "x" ]; then
                return
            fi
        fi
        local s="test"
        [ "x${MQTT_SPACE}" != "x" ] && local s="${MQTT_SPACE}/test"
        SSL_OPTS=
        if [ "x$MQTT_CAFILE" != "x" ]; then
            SSL_OPTS="--cafile $MQTT_CAFILE"
            [ "x$MQTT_CERT" != "x" ] && SSL_OPTS="$SSL_OPTS --cert $MQTT_CERT"
            [ "x$MQTT_KEY" != "x" ] && SSL_OPTS="$SSL_OPTS --key $MQTT_KEY"
        fi
        ./sbin/check-mqtt ${SSL_OPTS} \
            ${MQTT_USER}:${MQTT_PASSWORD}@${MQTT_HOST}:${MQTT_PORT}/${MQTT_SPACE} > /dev/null 2>&1
        if [ $? -ne 0 ]; then
            if [ ${INTERACTIVE} -ne 1 ]; then
                echo "MQTT test failed"
                exit 5
            fi
        else
            if [ $INTERACTIVE -eq 1 ]; then
                askYN "Enable node announcements and API calls via MQTT"
                MQTT_ANNOUNCE_ENABLED=$VALUE
                askYN "Enable autodiscovery of other nodes via MQTT"
                MQTT_DISCOVERY_ENABLED=$VALUE
            fi
            return
        fi
        echo "MQTT test failed"
    done
}

function askUser {
    USER=$2
    [ $INTERACTIVE -ne 1 ] && return
    while [ 1 ]; do
        echo -n "$1 [$2]: "
        read u
        if [ "x$u" == "x" ]; then
            u=$2
        fi
        id $u > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            su - $u -c "ls" > /dev/null 2>&1
            if [ $? -eq 0 ]; then
                USER=$u
                return
            fi
            echo "User $u has no shell set"
        fi
        echo "Invalid user: $u"
    done
}

while [[ $# -gt 0 ]]
do
    key="$1"
    case $key in
        --link)
            LINK=1
            shift
        ;;
        --mqtt)
            M=$2
            echo "x$M" |grep '@' > /dev/null
            if [ $? -eq 0 ]; then
                MQTT_AUTH=`echo $M|cut -d@ -f1`
                MQTT_USER=`echo $MQTT_AUTH|cut -d: -f1`
                echo "x$MQTT_AUTH" |grep ':' > /dev/null && MQTT_PASSWORD=`echo $M|cut -d@ -f1|cut -d: -f2`
            fi
            MQTT_HOST=`echo $M|cut -d@ -f2|cut -d: -f1|cut -d/ -f1`
            MQTT_PORT=`echo $M|cut -d@ -f2 |cut -d/ -f1|awk -F: '{ print $2 }'`
            [ "x$MQTT_PORT" = "x" ] && MQTT_PORT=1883
            echo "x$M" |grep '/' > /dev/null && MQTT_SPACE=`echo $M|cut -d/ -f2-`
            shift
            shift
        ;;
        --mqtt-cafile)
            MQTT_CAFILE=$2
            if [ ! -f $2 ]; then
                echo "No such MQTT CA file: $2"
                exit 5
            fi
            shift
            shift
        ;;
        --mqtt-cert)
            MQTT_CERT=$2
            if [ ! -f $2 ]; then
                echo "No such MQTT cert file: $2"
                exit 5
            fi
            shift
            shift
        ;;
        --mqtt-key)
            MQTT_KEY=$2
            if [ ! -f $2 ]; then
                echo "No such MQTT key file: $2"
                exit 5
            fi
            shift
            shift
        ;;
        --mqtt-announce)
            MQTT_ANNOUNCE_ENABLED=1
            shift
        ;;
        --mqtt-discovery)
            MQTT_DISCOVERY_ENABLED=1
            shift
        ;;
        -u)
            DEFAULT_USER="$2"
            shift
            shift
        ;;
        -p)
            case $2 in
                uc|UC)
                    INSTALL_UC=1
                ;;
                lm|LM)
                    INSTALL_LM=1
                ;;
                sfa|SFA)
                    INSTALL_SFA=1
                ;;
                all)
                    INSTALL_UC=1
                    INSTALL_LM=1
                    INSTALL_SFA=1
                ;;
                *)
                    option_error
                ;;
            esac
            shift
            shift
        ;;
        --local-only)
            echo "This controller will be installed with local-only key access"
            REMOTES="127.0.0.1"
            shift
        ;;
        --force)
            echo "Warning: using force installation, stopping EVA and removing old configs"
            FORCE=1
            ./sbin/eva-control stop
            shift
        ;;
        --clear)
            echo "Warning: asked to clear runtime. Performing"
            ./sbin/eva-control stop
            rm -rf runtime/*
            rm -f etc/eva_servers
            shift
        ;;
        -h|--help)
            usage
            exit 99
        ;;
        --auto)
            INTERACTIVE=0
            echo "Will perform automatic install"
            shift
        ;;
        --root)
            ALLOW_ROOT=1
            shift
        ;;
        --benchmark)
            echo "Will setup UC and do benchmark"
            if [ -f ./etc/uc.ini ]; then
                echo "etc/uc.ini already exists. Aborting"
                exit 5
            fi
            INTERACTIVE=0
            INSTALL_UC=1
            cp -v ./etc/uc.ini-benchmark ./etc/uc.ini
            BENCHMARK=1
            shift
        ;;
        *)
            option_error
        ;;
    esac
done

if [ "x$ALLOW_ROOT" != "x1" ] && [ "x`id -u`" != "x0" ]; then
    echo "Please run this script as root"
    exit 98
fi

if [ $LINK -eq 1 ] && [ "x$MQTT_HOST" = "x" ]; then
    echo "Linking requested but no MQTT HOST specified"
    option_error
fi

if [ ! $SKIP_CHECK ]; then
    e=0
    for r in ${REQUIRED}; do
        check_required_exec $r || e=1
    done
    [ $e -ne 0 ] && exit 1
fi


D=`realpath $0`
cd `dirname ${D}`

echo


if [ -f ./etc/eva_servers ]; then
    echo "Installed system detected"
    source ./etc/eva_servers
    source ./etc/easy_setup
    [ "x$UC_ENABLED" == 'xyes' ] && PRD=uc
    [ "x$LM_ENABLED" == 'xyes' ] && PRD=lm
    [ "x$SFA_ENABLED" == 'xyes' ] && PRD=sfa
    echo "Will use settings from $PRD"
    eval "`./sbin/get-setup-options $PRD`" || exit 1
    APPEND=1
fi

[ $MASTERKEY ] || MASTERKEY=`head -1024 /dev/urandom | sha256sum | awk '{ print $1 }'`
[ $DEFAULTKEY ] || DEFAULTKEY=`head -1024 /dev/urandom | sha256sum | awk '{ print $1 }'`
[ $OPKEY ] || OPKEY=`head -1024 /dev/urandom | sha256sum | awk '{ print $1 }'`

if [ $INTERACTIVE -eq 1 ]; then
    echo
    echo "Your masterkey: ${MASTERKEY}"
    echo "Your controller default key: ${DEFAULTKEY}"
    echo "Your operator key: ${OPKEY}"
    echo
    cat << EOF
WARNING: If you want to run some components under restricted users, create
"var" and "log" folders in EVA installation dir and make sure the restricted
users have an access to these folders before continuing easy-setup. If you've
customized ini files in etc, make sure the restricted user has an access to
both <component>.ini and <component>_apikeys.ini.

Press ENTER to continue easy-setup, Ctrl+C to abort.
EOF
    read
    echo
fi

# check mods

if [ ! $SKIP_CHECK ]; then
    echo "Checking mods"
    ./install/check-mods install || exit 1
    echo
fi

# ASK SOME QUESTIONS

if [ $APPEND -ne 1 ]; then
    echo
    askYN "Should this controller grant API access for the local instances only"
    [ $VALUE == "1" ] && REMOTES="127.0.0.1"
    askMQTT
fi


if [ "x$MQTT_HOST" != "x" ] && [ $APPEND -ne 1 ]; then
    echo
    askYN "Link controllers statically"
    [ $VALUE == "1" ] && LINK=1
fi

[ $APPEND -ne 1 ] && echo -n > etc/eva_servers

[ ! -f etc/watchdog ] && cp -vf etc/watchdog-dist etc/watchdog

# INSTALL UC

if [ "x$UC_ENABLED" != "xyes" ] || [ $FORCE -eq 1 ]; then
    echo
    askYN "Install EVA Universal Controller on this host"
    [ $VALUE == "1" ] && INSTALL_UC=1
else
    echo "UC is already installed. Skipping"
    INSTALL_UC=0
fi

echo

if [ $INSTALL_UC -eq 1 ]; then
    echo "Installing EVA Universal Controller"
    bash install/install-uc || exit 1
    echo "UC_ENABLED=yes" >> etc/eva_servers
    echo
    askUser "Enter the user account to run under (root is recommended for UC)" ${DEFAULT_USER}
    id ${USER} > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo "Invalid user: ${USER}"
        exit 2
    fi
    su - ${USER} -c "ls" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo "User ${USER} has no valid shell set"
        exit 2
    fi
    [ ! -f etc/uc.ini ] && cp etc/uc.ini-dist etc/uc.ini
    chmod 644 etc/uc.ini
    echo "Generating uc_apikeys.ini"
    rm -f etc/uc_apikeys.ini
    cat > etc/uc_apikeys.ini << EOF
[masterkey]
key = ${MASTERKEY}
master = yes
hosts_allow = ${REMOTES}

EOF
    chmod 600 etc/uc_apikeys.ini
    create_notifier uc || exit 1
    UC_USER=${USER}
    if [ "x$USER" != "xroot" ]; then
        chmod 777 runtime/db
        ./install/set-run-under-user uc ${USER} || exit 1
    fi
    start_controller uc
    if [ $? != 0 ]; then
        echo "Unable to test UC"
        ./sbin/eva-control stop
        exit 5
    fi
    echo "Creating UC keys"
    create_operator_key uc || exit 21
    create_default_key uc cmd,device || exit 22
    save_controller_state uc || exit 23
    echo
fi

# INSTALL LM

if [ "x$LM_ENABLED" != "xyes" ] || [ $FORCE -eq 1 ]; then
    askYN "Install EVA Logical Manager PLC on this host"
    [ $VALUE == "1" ] && INSTALL_LM=1
else
    echo "LM is already installed. Skipping"
    INSTALL_LM=0
fi

echo

if [ $INSTALL_LM -eq 1 ]; then
    echo "Installing EVA LM PLC"
    bash install/install-lm || exit 1
    echo "LM_ENABLED=yes" >> etc/eva_servers
    echo
    askUser "Enter the user account to run under (use root only if you are sure)" ${DEFAULT_USER}
    id ${USER} > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo "Invalid user: ${USER}"
        exit 2
    fi
    su - ${USER} -c "ls" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo "User ${USER} has no valid shell set"
        exit 2
    fi
    [ ! -f etc/lm.ini ] && cp etc/lm.ini-dist etc/lm.ini
    chmod 644 etc/lm.ini
    echo "Generating lm_apikeys.ini"
    rm -f etc/lm_apikeys.ini
    cat > etc/lm_apikeys.ini << EOF
[masterkey]
key = ${MASTERKEY}
master = yes
hosts_allow = ${REMOTES}

EOF
    chmod 600 etc/lm_apikeys.ini
    create_notifier lm || exit 1
    LM_USER=${USER}
    if [ "x$USER" != "xroot" ]; then
        chmod 777 runtime/db
        ./install/set-run-under-user lm ${USER} || exit 1
    fi
    start_controller lm
    if [ $? != 0 ]; then
        echo "Unable to test LM"
        ./sbin/eva-control stop
        exit 5
    fi
    echo "Creating LM keys"
    create_operator_key lm || exit 21
    create_default_key lm dm_rule_props,dm_rules_list || exit 22
    save_controller_state lm || exit 23
    if [ $LINK -eq 1 ] && [ $INSTALL_UC -eq 1 ]; then
        echo "Linking local UC to LM PLC"
        (./sbin/eva-tinyapi -C lm -F append_controller \
            u=http://localhost:8812 a=\$default m=eva_1 save=1 | grep OK) > /dev/null 2>&1
        if [ $? != 0 ]; then
            echo "Linking failed!"
            ./sbin/eva-control stop
            exit 5
        fi
    fi
    echo
fi

# INSTALL SFA

if [ "x$SFA_ENABLED" != "xyes" ] || [ $FORCE -eq 1 ]; then
    askYN "Install SCADA Final Aggregator on this host"
    [ $VALUE == "1" ] && INSTALL_SFA=1
else
    echo "SFA is already installed. Skipping"
    INSTALL_SFA=0
fi

echo

if [ $INSTALL_SFA -eq 1 ]; then
    echo "Installing EVA SFA"
    bash install/install-sfa || exit 1
    echo "SFA_ENABLED=yes" >> etc/eva_servers
    echo
    askUser "Enter the user account to run under (root is not recommended!)" ${DEFAULT_USER}
    id ${USER} > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo "Invalid user: ${USER}"
        exit 2
    fi
    su - ${USER} -c "ls" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo "User ${USER} has no valid shell set"
        exit 2
    fi
    [ ! -f etc/sfa.ini ] && cp etc/sfa.ini-dist etc/sfa.ini
    chmod 644 etc/sfa.ini
    echo "Generating sfa_apikeys.ini"
    rm -f etc/sfa_apikeys.ini
    cat > etc/sfa_apikeys.ini << EOF
[masterkey]
key = ${MASTERKEY}
master = yes
hosts_allow = ${REMOTES}

EOF
    chmod 600 etc/sfa_apikeys.ini
    create_notifier sfa || exit 1
    SFA_USER=${USER}
    if [ "x$USER" != "xroot" ]; then
        chmod 777 runtime/db
        ./install/set-run-under-user sfa ${USER} || exit 1
    fi
    start_controller sfa
    if [ $? != 0 ]; then
        echo "Unable to test SFA"
        ./sbin/eva-control stop
        exit 5
    fi
    echo "Creating SFA keys"
    create_operator_key sfa || exit 21
    create_default_key sfa || exit 22
    save_controller_state sfa || exit 23
    if [ $LINK -eq 1 ] && [ $INSTALL_UC -eq 1 ]; then
        echo "Linking local UC to SFA"
        (./sbin/eva-tinyapi -C sfa -F append_controller \
            g=uc u=http://localhost:8812 a=\$default m=eva_1 save=1 | grep OK ) > /dev/null 2>&1
        if [ $? != 0 ]; then
            echo "Linking failed!"
            ./sbin/eva-control stop
            exit 5
        fi
    fi
    if [ $LINK -eq 1 ] && [ $INSTALL_LM -eq 1 ]; then
        echo "Linking local LM PLC to SFA"
        (./sbin/eva-tinyapi -C sfa -F append_controller \
            g=lm u=http://localhost:8817 a=\$default m=eva_1 save=1 | grep OK ) > /dev/null 2>&1
        if [ $? != 0 ]; then
            echo "Linking failed!"
            ./sbin/eva-control stop
            exit 5
        fi
    fi
    echo
fi

# COMPLETED

if [ $INSTALL_UC -eq 0 ] && [ $INSTALL_LM -eq 0 ] && [ $INSTALL_SFA -eq 0 ]; then
    echo "No products selected, nothing was installed"
    exit 0
fi

USERS=

[ "x${UC_USER}" != "x" ] && [ "x${UC_USER}" != "xroot" ] && USERS="${USERS} ${UC_USER}"
[ "x${LM_USER}" != "x" ] && [ "x${LM_USER}" != "xroot" ] && USERS="${USERS} ${LM_USER}"
[ "x${SFA_USER}" != "x" ] && [ "x${SFA_USER}" != "xroot" ] && USERS="${USERS} ${SFA_USER}"

X=

for u in ${USERS}; do
    if [ "x$X" != "x" ] && [ "x$X" != "x$u" ]; then
        X=
        break
    fi
    X=$u
done

if [ "x$X" != "x" ]; then
    chown ${X} runtime/db
    chmod 700 runtime/db
fi

echo "Setup completed!"
echo
echo "MASTERKEY: ${MASTERKEY}"
echo "Controller default key: ${DEFAULTKEY}"
echo "Operator key: ${OPKEY}"
echo

mkdir -p backup
chmod 700 backup

echo "MQTT_DISCOVERY_ENABLED=$MQTT_DISCOVERY_ENABLED" > ./etc/easy_setup
echo "LINK=$LINK" >> ./etc/easy_setup

if [ $BENCHMARK -eq 1 ]; then
    echo "Starting CRT benchmark"
    echo
    ./tests/benchmark-uc-crt
    ./sbin/eva-control stop
fi

exit 0
