#!/usr/bin/env python3

__author__ = "Altertech Group, https://www.altertech.com/"
__copyright__ = "Copyright (C) 2012-2018 Altertech Group"
__license__ = "https://www.eva-ics.com/license"
__version__ = "3.1.0"

import os
import sys
import getopt
import jsonpickle

dir_lib = os.path.dirname(os.path.realpath(__file__)) + '/../lib'
sys.path.append(dir_lib)

from eva.client import apiclient

import eva.core
from eva.tools import print_json


def usage():
    print()
    print('EVA UC CLI version %s' % (apiclient.version))
    print("""
Usage: uc-cmd <command> [args] [-U API uri] [-K key] [-T sec] [-D]

    -U   specify API uri (http://host:port), if no uri specified, API will be
         called in local mode (with data from ../etc/uc.ini and uc_apikeys.ini)
    -K   key, if no key specified, local master key will be used (if local API)
    -T   API request timeout
    -D   Enable debug messages

each command calls the corresponding API function and returns API JSON result

System commands:

    test                                      test API and get system info

    cmd <-c cmdname> [-a args] [-w sec] [-t sec]
                                              launch remote script/program from
                                              xc/cmd/ with optional args
                                              -w sec  wait seconds for a result
                                              -t sec  max command exection time

    lock <-l lockname> [-t sec] [-e sec]      acquire lock which expires in
                                              -e sec, wait -t sec to acquire

    unlock <-l lockname>                      release lock

    log_rotate                                rotate server logs

    log_debug <-m msg>                        put debug log message
    log_info <-m msg>                         put info log message
    log_warning <-m msg>                      put warning log message
    log_error <-m msg>                        put error log message
    log_critical <-m msg>                     put critical log message
    log_get <-l level> <-t sec> <-n entries>  get server log entries,
                                                l = log level,
                                                t = seconds to past,
                                                n - max entries

    save                                      save runtime config and database


    get_cvar [-i var]                         return value of custom variable
                                              for xc, if var not specified,
                                              return all variables

    set_cvar <-i var> [-v value]              define custom variable for xc,
                                              unset if value not specified

    debug - set server debug mode on
    nodebug - set server debug mode off


UC commands:

    state <-p tp> [-i id] [-y] [-g group]     get unit/sensor state, specify
                                              either:
                                                -i unit/sensor id, or
                                                -p item type (U for unit,
                                                              S for sensor)

                                              -g  filter by group, you may use
                                                  # and + for group wildcard
                                                  (mqtt style)

                                              -y  get full item info
                                                  (description etc.)

    update <-i id> [-s status] [-v value]     update unit/sensor state,
                                              status = always integer number

    action <-i id> <-s status> [-v value] [-p priority]
                               [-w sec] [-q sec] [-u uuid]
                                              execute unit action, wait -w sec
                                              to complete. if wait time
                                              expires, returns current action
                                              state

                                              you may define own action uuid
                                              but it's not recommended unless
                                              you know what you are doing

                                              -q - seconds to wait for action
                                              processing in the main queue

    action_toggle <-i id> [-p priority] [-w sec] [-q sec] [-u uuid]
                                              execute unit action to toggle
                                              it's status (set 1 if 0, 0 if 1).
                                              Options and behaviour are equal
                                              to action command.

    result [-u uuid] [-i id] [-g grp] [-s state]
                                              get action result(s), filter by
                                               -u  action uuid
                                               -i  unit id
                                               -g  group
                                               -s  state (Q,R,F -
                                                   queued, running, finished)


    enable_actions <-i id>                    enable actions of unit, save
                                              config property instantly

    disable_actions <-i id>                   disable actions of unit save
                                              config property instantly

    terminate [-u uuid] [-i id]               terminate running action, either
                                              by action uuid, or by item id.
                                              if action uuid is specified but
                                              action is still queued, it will
                                              be canceled

    q_clean <-i id>                           clean action queue for the unit,
                                              don't terminate current running
                                              action

    kill <-i id>                              clean action queue for the unit
                                              plus terminate current running 
                                              action

Configure items (requires master key):

    list [-g group] [-p tp]                   brief list of configurable items,
                                              filter by:
                                                -p  item type (U for unit,
                                                    S for sensor)

                                                -g  filter by group, you may
                                                    use # and + for group
                                                    wildcard (mqtt style)

    get_config <-i id>                        get item configuration

    save_config <-i id>                       save item configuration, modified
                                              item config will be also save on
                                              exit (if db_update isn't set to 
                                              manual) and when save API
                                              function/command is called


    list_props <-i id>                        list item properties allowed to
                                              be modified

    set_prop <-i id> <-p prop> [-v val] [-y]
                                              set item property to specified
                                              value, unset property (set to
                                              default) if -v key is not
                                              specified

                                              -y option will save item config
                                              if the property got the new value

    create_unit <-i id> [-g group] [-y] [-z]
    create_sensor <-i id> [-g group] [-y] [-z]
    create_mu <-i id> [-g group] [-y] [-z]
                                              create new unit, sensor or
                                              multiupdate, if group is not
                                              specified, 'nogroup' will be
                                              assigned.

                                                 -y  save item config right
                                                     after creation
                                                 -z  create virtual item

    clone <-i id> <-n new_id> [-g group] [-y]
                                              clone item, put a new item into
                                              the group if specified

                                                 -y  save item config right
                                                     after creation

    clone_group <-g group> <-n new_group>
                <-p item_prefix> <-r new_item_prefix> [-y]

                                              clone all items in group with ids
                                              starting with item_prefix into a
                                              new group, replace item_prefix to
                                              new_item_prefix

                                                 -y  save item config right
                                                     after creation

    destroy <-i id|-g group>                  destroy an item or all items in
                                              the group

    create_device <-t tpl> [-c cfg] [-y]      create device (set of items and
                                              cvars) from template

                                                 -y  save items configs right
                                                     after creation

    update_device <-t tpl> [-c cfg] [-y]      update device (set of items and
                                              cvars) from template

                                                 -y  save items configs right
                                                     after update

    destroy_device <-t tpl> [-c cfg]          destroy device (set of items and
                                              cvars) from template

File management in runtime (requires master key):

    file_get <-i file>                        get file from runtime

    file_put <-i file> [-m content]           put file into runtime with
                                              content string specified in -m

    file_put <-i file> <-l local file>        put local text file into runtime

    file_set_exec <-i file> <-e 0|1>          set file executable
                                               -e 1   exec enabled (perm 0755)
                                               -e 0   exec disabled (perm 0644)

    file_unlink <-i file>                     remove file from runtime

User management in runtime (requires master key):

    list_keys                                 list API key IDs

    list_users                                list users

    create_user <-u username> <-p password> <-a apikey_id>
                                              create new user

    set_user_password <-u username> <-p password>
                                              modify user password

    set_user_key <-u username> <-p apikey_id>
                                              modify user API key ID

    destroy_user <-u username>                delete user

Exit codes:

the exit codes are equal to the return codes of API client:

    0   everything is okay
    1   item (i.e. unit) not found or command was executed with wrong params
    2   forbidden (access to the object or function is denied)
    3   API returned error 500 (wrong params - used string instead of number
        etc.)
    4   API returned unknown error, try enabling debug mode and repeat,
        maybe it's a bug
    5   API not ready. returns when unable to open etc/uc.ini or uc_apikeys.ini
        and API uri was not specified
    6   unknown command/function or no function specified
    7   server error (unable to connect etc.)
    8   server timeout
    9   server returned bad data (not JSON)
    10  command/function failed (i.e. executed action/cmd was completed with
        an error)
    11  invalid command params

    99  if no command specified
    """)


xparams = {}
timeout = None
apikey = None
apiuri = None

debug = False

try:
    func = sys.argv[1]
    o, a = getopt.getopt(sys.argv[2:],
            'K:T:U:m:a:c:l:t:e:n:i:u:g:p:q:r:s:v:w:x:yzD')
except:
    usage()
    sys.exit(99)

for i, v in o:
    if i == '-y':
        xparams['full'] = '1'
    elif i == '-z':
        xparams['virtual'] = '1'
    elif i == '-T':
        try:
            timeout = float(v)
        except:
            usage()
            sys.exit(99)
    elif i == '-U':
        apiuri = v
        if apiuri[-1] == '/': apiuri = apiuri[:-1]
    elif i == '-K':
        apikey = v
    elif i == '-D':
        debug = True
    else:
        xparams[i[1:]] = v

if not apiuri:
    try:
        api = apiclient.APIClientLocal('uc')
    except:
        print('Can not init API, uc.ini or uc_apikeys.ini missing?')
        sys.exit(98)
else:
    api = apiclient.APIClient()
    api.set_uri(apiuri)
    api.set_product('uc')

if apikey is not None:
    api.set_key(apikey)

api.ssl_verify(False)

params = {}

if ( func == 'set_prop' or \
        func == 'create_device' or \
        func == 'update_device' or \
        func == 'load_phi' or \
        func == 'load_driver' or \
        func == 'clone' or \
        func == 'clone_group' or \
        func == 'create_unit' or \
        func == 'create_sensor' or \
        func == 'create_mu' ) and \
            'full' in xparams and xparams['full'] == '1':
    del xparams['full']
    params['save'] = '1'

if func == 'debug':
    params['debug'] = 1
    func = 'set_debug'
elif func == 'nodebug':
    params['debug'] = 0
    func = 'set_debug'
else:
    params.update(xparams)

if func == 'file_put':
    if not 'm' in params:
        if not 'l' in params:
            usage()
            sys.exit(99)
        try:
            params['m'] = ''.join(open(params['l']).readlines())
            del params['l']
        except:
            print('Can\'t read local file %s' % params['l'])
            sys.exit(apiclient.result_not_found)

code, result = api.call(func, params, timeout, _debug=debug)

if code != apiclient.result_ok and \
        code != apiclient.result_func_failed:
    if code == apiclient.result_not_found:
        print('Error: Object not found')
    elif code == apiclient.result_forbidden:
        print('Error: Forbidden')
    elif code == apiclient.result_api_error:
        print('Error: API error')
    elif code == apiclient.result_unknown_error:
        print('Error: Unknown error')
    elif code == apiclient.result_not_ready:
        print('Error: API not ready')
    elif code == apiclient.result_func_unknown:
        usage()
    elif code == apiclient.result_server_error:
        print('Error: Server error')
    elif code == apiclient.result_server_timeout:
        print('Error: Server timeout')
    elif code == apiclient.result_bad_data:
        print('Error: Bad data')
    elif code == apiclient.result_invalid_params:
        print('Error: invalid params')
    sys.exit(code)
else:
    if func in ['action'] and \
        'status' in result and \
        result['status'] == 'completed':
        t1 = result['time']['created']
        t2 = result['time']['completed']
        xtime = t2 - t1
        print('Exec time: %f sec  ( %f ms )' % (xtime, xtime * 1000))
    print_json(result)

sys.exit(code)
