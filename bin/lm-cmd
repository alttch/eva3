#!/usr/bin/env python3

__author__ = "Altertech Group, http://www.altertech.com/"
__copyright__ = "Copyright (C) 2012-2018 Altertech Group"
__license__ = "See http://www.eva-ics.com/"
__version__ = "3.0.2"

import os
import sys
import getopt
import jsonpickle

dir_lib = os.path.dirname(os.path.realpath(__file__)) + '/../lib'
sys.path.append(dir_lib)

from eva.client import apiclient

import eva.core
from eva.tools import print_json


def usage():
    print()
    print('EVA LM CLI version %s' % (apiclient.version))
    print("""
Usage: lm-cmd <command> [args] [-U API uri] [-K key] [-T sec] [-D]

    -U   specify API uri (http://host:port), if no uri specified, API will be
         called in local mode (with data from ../etc/lm.ini and lm_apikeys.ini)
    -K   key, if no key specified, local master key will be used (if local API)
    -T   API request timeout
    -D   Enable debug messages

each command calls the corresponding API function and returns API JSON result

System commands:

    test                                      test API and get system info

    cmd <-c cmdname> [-a args] [-w sec] [-t sec]
                                              launch remote script/program from
                                              xc/cmd/ with optional args
                                              -w sec  wait seconds for a result
                                              -t sec  max command exection time

    lock <-l lockname> [-t sec] [-e sec]      acquire lock which expires in
                                              -e sec, wait -t sec to acquire

    unlock <-l lockname>                      release lock

    log_rotate                                rotate server logs

    log_debug <-m msg>                        put debug log message
    log_info <-m msg>                         put info log message
    log_warning <-m msg>                      put warning log message
    log_error <-m msg>                        put error log message
    log_critical <-m msg>                     put critical log message
    log_get <-l level> <-t sec> <-n entries>  get server log entries,
                                                l = log level,
                                                t = seconds to past,
                                                n - max entries

    save                                      save runtime config and database


    get_cvar [-i var]                         return value of custom variable
                                              for xc, if var not specified,
                                              return all variables

    set_cvar <-i var> [-v value]              define custom variable for xc,
                                              unset if value not specified

    debug - set server debug mode on
    nodebug - set server debug mode off


LM commands:

    state [-i id] [-y] [-g group]             get lvar state

                                               -i  lvar id
                                               -g  filter by group, you may use
                                                   # and + for group wildcard
                                                   (mqtt style)
                                               -y  get full lvar info
                                                   (description etc.)

    set <-i id> [-s status] [-v value]        set lvar state,
                                              status = -1 , 0 or 1

    reset <-i id>                             reset lvar when used as timer,
                                              set status = 1, value = "1"


    list_macros [-g group]                    list available macros, filter
                                              by group if specified

    run <-i macro_id> [-a args] [-p priority] [-w sec] [-q sec] [-u uuid]
                                              execute macro with args specified
                                              in -a, wait -w sec to complete.
                                              if wait time expires, returns
                                              current action state

                                              you may define own action uuid
                                              but it's not recommended unless
                                              you know what you are doing

                                              -q - seconds to wait for action
                                              processing in the main queue

    result [-u uuid] [-i id] [-g grp] [-s state]
                                              get macro execution result(s),
                                              filter by
                                               -u  action uuid
                                               -i  macro id
                                               -g  group
                                               -s  state (Q,R,F -
                                                   queued, running, finished)

Configure items (requires master key):

    list [-g group] [-p tp]                   brief list of configurable items,
                                              filter by:

                                                -p  item type (LV for lvar)

                                                -g  filter by group, you may
                                                    use # and + for group
                                                    wildcard (mqtt style)

    get_config <-i id>                        get lvar configuration

    save_config <-i id>                       save lvar configuration, modified
                                              lvar config will be also save on
                                              exit (if db_update isn't set to 
                                              manual) and when save API
                                              function/command is called


    list_props <-i id>                        list lvar properties allowed to
                                              be modified

    set_prop <-i id> <-p prop> [-v val] [-y]
                                              set lvar property to specified
                                              value, unset property (set to
                                              default) if -v key is not
                                              specified

                                              -y option will save lvar config
                                              if the property got the new value

    create_lvar <-i id> [-g group] [-y]
                                              create new lvar, if group is not
                                              specified, 'nogroup' will be
                                              assigned.

                                                 -y  save item config right
                                                     after creation

    destroy_lvar <-i id>                      destroy lvar


Macros management in runtime (requires master key):

    list_macro_props <-i id>                  list macro properties allowed to
                                              be modified


    set_macro_prop <-i id> <-p prop> [-v val] [-y]
                                              set macro property to specified
                                              value, unset property (set to
                                              default) if -v key is not
                                              specified

                                              -y option will save macro config
                                              if the property got the new value

    create_macro <-i id> [-g group] [-y]      create macro configuration

                                              -g  macro group
                                              -y  save macro config after
                                                  creation

    destroy_macro <-i id>                     destroy macro configuration


Decision Matrix management in runtime (requires master key or a key with
allow = dm_rules for in_range_*, enabled and chillout_time prop management):

    list_rules                                list DM rules, requires master
                                              key only

    list_rule_props <-i id>                   list DM rule properties allowed
                                              to be modified

    set_rule_prop <-i id> <-p prop> [-v val] [-y]
                                              set DM rule property to specified
                                              value, unset property (set to
                                              default) if -v key is not
                                              specified

                                              -y option will save rule config
                                              if the property got the new value

    create_rule [-y]                          create new DM rule, rule id
                                              will be returned in result,
                                              requires master key only

                                              -y  save rule config after
                                                  creation

    destroy_rule <-i id>                      destroy specified DM rule,
                                              requires master key only


Controller management in runtime (requires master key):

    list_remote [-p type] [-i controller] [-g group]
                                              list remote items

                                              -p  filter by item type (unit,
                                                  sensor)
                                              -i  filter by UC
                                              -g  filter by group, you may use
                                                  # and + for group wildcard
                                                  (mqtt style)

    list_controllers                          list connected UCs

    list_controller_props <-i id>             list UC properties allowed to
                                              be modified

    set_controller_prop <-i id> <-p prop> [-v val] [-y]
                                              set UC property to specified
                                              value, unset property (set to
                                              default) if -v key is not
                                              specified

                                              -y option will save UC config
                                              if the property got the new value

    append_controller <-u URI> [-a apikey] [-m mqtt_notifier] [-s ssl_verify]
                               [-t timeout] [-y]
                                              append UC by API URI
                                              -a  remote controller apikey
                                              -m  local mqtt notifier to sync
                                              -s  verify SSL or not (1|0) when
                                                  calling API
                                              -t  API timeout
                                              -y  save UC config after creation

    remove_controller <-i id>                 remove UC

    reload_controller <-i id>                 reload UC items

File management in runtime (requires master key):

    file_get <-i file>                        get file from runtime

    file_put <-i file> [-m content]           put file into runtime with
                                              content string specified in -m

    file_put <-i file> <-l local file>        put local text file into runtime

    file_set_exec <-i file> <-e 0|1>          set file executable
                                               -e 1   exec enabled (perm 0755)
                                               -e 0   exec disabled (perm 0644)

    file_unlink <-i file>                     remove file from runtime

User management in runtime (requires master key):

    list_keys                                 list API key IDs

    list_users                                list users

    create_user <-u username> <-p password> <-a apikey_id>
                                              create new user

    set_user_password <-u username> <-p password>
                                              modify user password

    set_user_key <-u username> <-p apikey_id>
                                              modify user API key ID

    destroy_user <-u username>                delete user

Exit codes:

the exit codes are equal to the return codes of API client:

    0   everything is okay
    1   object (i.e. unit) not found or command was executed with wrong params
    2   forbidden (access to the object or function is denied)
    3   API returned error 500 (wrong params - used string instead of number
        etc.)
    4   API returned unknown error, try enabling debug mode and repeat,
        maybe it's a bug
    5   API not ready. returns when unable to open etc/lm.ini or lm_apikeys.ini
        and API uri was not specified
    6   unknown command/function or no function specified
    7   server error (unable to connect etc.)
    8   server timeout
    9   server returned bad data (not JSON)
    10  command/function failed (i.e. executed action/cmd was completed with
        an error)

    99  if no command specified
    """)


xparams = {}
timeout = None
apikey = None
apiuri = None

debug = False

try:
    func = sys.argv[1]
    o, a = getopt.getopt(sys.argv[2:],
                         'K:T:U:m:a:c:l:t:e:n:i:u:g:p:q:s:v:w:yzD')
except:
    usage()
    sys.exit(99)

for i, v in o:
    if i == '-y':
        xparams['full'] = '1'
    elif i == '-z':
        xparams['virtual'] = '1'
    elif i == '-T':
        try:
            timeout = float(v)
        except:
            usage()
            sys.exit(99)
    elif i == '-U':
        apiuri = v
        if apiuri[-1] == '/': apiuri = apiuri[:-1]
    elif i == '-K':
        apikey = v
    elif i == '-D':
        debug = True
    else:
        xparams[i[1:]] = v

if not apiuri:
    try:
        api = apiclient.APIClientLocal('lm')
    except:
        print('Can not init API, lm.ini or lm_apikeys.ini missing?')
        sys.exit(98)
else:
    api = apiclient.APIClient()
    api.set_uri(apiuri)
    api.set_product('lm')

if apikey is not None:
    api.set_key(apikey)

api.ssl_verify(False)

params = {}

if ( func == 'set_prop' or \
        func == 'set_controller_prop' or \
        func == 'set_macro_prop' or \
        func == 'set_rule_prop' or \
        func == 'create_rule' or \
        func == 'create_macro' or \
        func == 'append_controller' or \
        func == 'create_lvar' ) \
        and 'full' in xparams and xparams['full'] == '1':
    del xparams['full']
    params['save'] = '1'

if func == 'debug':
    params['debug'] = 1
    func = 'set_debug'
elif func == 'nodebug':
    params['debug'] = 0
    func = 'set_debug'
else:
    params.update(xparams)

if func == 'file_put':
    if not 'm' in params:
        if not 'l' in params:
            usage()
            sys.exit(99)
        try:
            params['m'] = ''.join(open(params['l']).readlines())
            del params['l']
        except:
            print('Can\'t read local file %s' % params['l'])
            sys.exit(apiclient.result_not_found)

code, result = api.call(func, params, timeout, _debug=debug)

if code != apiclient.result_ok and \
        code != apiclient.result_func_failed:
    if code == apiclient.result_not_found:
        print('Error: Object not found')
    elif code == apiclient.result_forbidden:
        print('Error: Forbidden')
    elif code == apiclient.result_api_error:
        print('Error: API error')
    elif code == apiclient.result_unknown_error:
        print('Error: Unknown error')
    elif code == apiclient.result_not_ready:
        print('Error: API not ready')
    elif code == apiclient.result_func_unknown:
        usage()
    elif code == apiclient.result_server_error:
        print('Error: Server error')
    elif code == apiclient.result_server_timeout:
        print('Error: Server timeout')
    elif code == apiclient.result_bad_data:
        print('Error: Bad data')
    sys.exit(code)
else:
    if func in ['run'] and \
        'status' in result and \
        result['status'] == 'completed':
        t1 = result['time']['created']
        t2 = result['time']['completed']
        xtime = t2 - t1
        print('Exec time: %f sec  ( %f ms )' % (xtime, xtime * 1000))
    print_json(result)

sys.exit(code)
